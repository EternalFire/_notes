
- [2019.12.07](#20191207)
- [2019.12.06](#20191206)

---

## 2019.12.07

中点计算: `mid = Math.floor((low + high) / 2)`

<br>

折半查找作用于升序数组, 查询target所在数组的index.

每次迭代都要判断target是在`[low,mid]`区间, 还是`[mid,high]`区间, 直到边界重合(`while(low <= mid)`).

- 判断区间后需要缩小范围:
  - 如果target是在`[low,mid]`区间, 则`high=mid-1`
  - 如果target是在`[mid,high]`区间, 则`low=mid+1`
- 判断数组在边界点(low,mid,high)上的值是否于target相等.
- 重新计算中点mid.

<br>

一元二次方程求根:

解法1:

$$
ax^2+bx+c = 0, (a \neq 0) \\
$$
$$
x_1 = \frac{-b-\sqrt{b^2-4ac}}{2a} \\
$$
$$
x_2 = \frac{-b+\sqrt{b^2-4ac}}{2a} \\
$$

两根的性质:

$$
x_1 + x_2 = - \frac{b}{a}
$$

$$
x_1 x_2 = \frac{c}{a}
$$

解法2:

$$
ax^2+bx+c = 0, (a \neq 0) \\
$$

$$
B=\frac{b}{a}, \ C=\frac{c}{a}
$$

$$
x_1 = -\frac{B}{2}-\sqrt{\frac{B^2}{4}-C}
$$


$$
x_2 = -\frac{B}{2}+\sqrt{\frac{B^2}{4}-C}
$$


---

## 2019.12.06

图搜索算法用到的数据结构:

DFS, depth first search, 深度优先搜索
- stack, 栈, 存放候选边
- visited, 键值类, `{id:boolean}`, 标记已经访问过的节点
- route, 键值类数组, `[{id:edge}]`, 记录到达节点的边
- source, 源节点
- target, 目标节点

BFS, breadth first search, 广度优先搜索
- queue, 队列, 存放候选边
- visited, 键值类, `{id:boolean}`, 标记已经访问过的节点
- route, 键值类数组, `[{id:edge}]`, 记录到达节点的边
- source, 源节点
- target, 目标节点

Dijkstra, 带权图的最短路径算法
- priority queue, 优先级队列, 存放候选节点ID, 根据从源节点到某节点的开销, 从小到大排序
- frontier, 键值类数组, `[{id:edge}]`, 记录到达候选节点的边
- cost, 键值类, `{id:number}`, 记录到达节点的开销
- route, 键值类数组, 记录到达节点的边, SPT(最短路径树)
- source, 源节点
- target, 目标节点

A*算法, 使用估算距离计算开销
- priority queue, 优先级队列, 存放候选节点ID, 根据从源节点到某节点的开销, 从小到大排序
- frontier, 键值类数组, `[{id:edge}]`, 记录到达候选节点的边
- gCost, 键值类, `{id:number}`, 记录到达节点的开销(G)
- hCostFunction, 启发函数(H), 计算节点到目标节点的估算距离
- cost, 键值类, `{id:number}`, 记录到达节点的 总开销(F), F=G+H
- route, 键值类数组, 记录到达节点的边
- source, 源节点
- target, 目标节点

共同点:

- 都是迭代候选边或节点, 直到找到目标节点.
- 取出候选边或节点后, 添加到route.
- route 保存的都是节点的入边, 即经过该节点需要经过的边.

