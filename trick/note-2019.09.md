
- [2019.09.08](#20190908)
- [2019.09.07](#20190907)
- [2019.09.06](#20190906)
- [2019.09.05](#20190905)
- [2019.09.04](#20190904)
- [2019.09.03](#20190903)
- [2019.09.02](#20190902)

---

## 2019.09.08

数据的形式:

- 程序中的数据结构
    - 对象, 容器
    - 数值
- 序列化
    - json, xml, ...

程序逻辑操作的是数据.

想到一个点子, 名字叫《假想老师》. 老师关注每个学生的历史状况, 从而作出决策.

描述历史的结构...


---

## 2019.09.07


清理 cocos2dx 资源搜索路径:

```lua
---
--- Helper:removeSearchPath("res/game_1/Animate", "res/game_1/Animate/image")
--- Helper:removeSearchPath(unpack({"res/game_1/Animate", "res/game_1/Animate/image"}))
---
function Helper:removeSearchPath(...)
    local _debug = false
    local paths = cc.FileUtils:getInstance():getSearchPaths()
    if _debug then
        dump(paths)
    end

    local new_paths = {}
    local cache = {}
    local filter = {}
    local game_path_to_remove = {...}

    for _, target in ipairs(game_path_to_remove) do
        for _, p in ipairs(paths) do
            local start_index, end_index = string.find(p, target)
            if start_index ~= nil then
                if not filter[p] then
                    filter[p] = true

                    if _debug then
                        print("find!", p, start_index, end_index)
                    end
                end
            end
        end
    end

    for _, p in ipairs(paths) do
        if not cache[p] then
            cache[p] = true
            if not filter[p] then
                table.insert(new_paths, p)
            end
        end
    end

    cc.FileUtils:getInstance():setSearchPaths(new_paths)
    local paths = cc.FileUtils:getInstance():getSearchPaths()
    if _debug then
        print("current search path:")
        dump(paths)
    end
end
```

---

## 2019.09.06

安装 pip

```
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
sudo python get-pip.py
```

安装 shadowsocks

`pip install shadowsocks`

shadowsocks 配置文件

```
cat /etc/shadowsocks.json

{
	"server": "192.168.43.252",
	"server_port": 9630,
	"local_port": 1080,
	"password": "fire",
	"timeout": 600,
	"method": "aes-256-cfb"
}
```

启动 shadowsocks

`sudo ssserver -c /etc/shadowsocks.json -d start`

关闭 shadowsocks

`sudo ssserver -d stop`

独立于游戏逻辑的常用功能模块:

- 对话框
- 签到
- 排行榜
- 信息展示
- 修改密码
- 设置
- 帮助
- 邮件
- 商城
- 抽奖功能

android 刷机的两个模式:

关机键 + 音量减小键, 进入 fastboot mode

关机键 + 音量增大键, 进入 recovery mode

Magisk 科普, http://www.oneplusbbs.com/thread-4077732-1-1.html

魔趣rom, https://www.mokeedev.com/

Android 四：区分刷机与root, https://www.cnblogs.com/happyliuyi/p/5166009.html


---

## 2019.09.05

查看当前ip的地区, `curl ip.gs`

WFilter(超级嗅探狗)局域网监控软件是为企业量身定做的信息监控系统.

pfctl 说明, https://www.freebsdchina.org/forum/topic_24641.html

网页版 NS2 实验平台的搭建, https://github.com/rocky-nupt/ns_web

NS3教程, https://blog.csdn.net/loloha007/article/details/8256090

https://www.computerhope.com/

android 路由
- https://www.cnblogs.com/simonshi/archive/2011/05/31/2065011.html
- https://blog.csdn.net/zhuxiaoping54532/article/details/51526304


---

## 2019.09.04

http://www.jacquesf.com/2011/04/mac-os-x-dhcp-server/

https://apple.stackovernet.com/cn/q/49684

Q:

`Router <-- USB ethernet --> MAC_GW <-- ethernet --> switch <-> internal network`

A:

```
OS X Yosemite doesn’t have support for natd binary or ipfw anymore. Instead pfctl is used.

I assume the following IP-adresses/netmasks:

Router: 192.168.0.1/24
Mac mini gateway: en0: 192.168.0.2/24 gateway 192.168.0.1 en1: 192.168.1.2/24
Internal network: 192.168.1.0/24

1. First you have to enable forwarding on your Mac computer with following commands:

sudo sysctl -w net.inet.ip.forwarding=1

2. In order to do NAT you have to create a pfctl rule. Create a file called "nat-rules" with the following content:

nat on en0 from en1 to any -> (en0)

3. Save the file and now start pfctl using the rule from the file we have created earlier:

sudo pfctl -d #disables pfctl
sudo pfctl -F all #flushes all pfctl rules
sudo pfctl -f /Path/to/file/nat-rules -e #starts pfctl and loads the rules from the nat-rules file

4. Now configure a static route on your router:

192.168.1.0/24 (the internal network) -> 192.168.0.2 (Mac mini IP-address of the external interface connected to the router)

5. Enable the DHCP-service on your Mac mini gateway:

Name: choose a name
Network Interface: en1
Starting IP address: 192.168.1.10
Ending IP address: 192.168.1.100
Subnet Netmask: 255.255.255.0
Router: 192.168.1.2
DNS: some DNS-server (e.g. 8.8.8.8)

6. Now use pfctl to add rules or get a pfctl-GUI like IceFloor or Murus to configure your firewall. Both apps should also allow you to enable NAT (step 2/3)
```


Mac设置同时访问内外网, https://www.jianshu.com/p/a9d458e97c40

```
netstat -rn    --查看路由表
route get 0.0.0.0 --获取默认路由
sudo route delete 0.0.0.0    --删除默认路由
sudo route add -net 0.0.0.0 192.168.1.1    --添加外网网关
sudo route add -net 134.0.0.0  134.81.5.254    --添加内网网关（注意这里ip地址是自己要访问内网的ip地址，如果只访问某一台，可以将134.0.0.0改成固定的IP，例如134.81.5.228）
```

Mac High Sierra 配置永久静态路由, https://blog.csdn.net/zh778/article/details/79401106
- networksetup 命令

```
networksetup -listallnetworkservices

配置路由
networksetip -setadditionalroutes "Ethernet 2" 192.168.43.0 255.255.255.0 192.168.8.63

清空已配置的路由
networksetip -setadditionalroutes "Ethernet 2"
```

`sysctl`

`pfctl`, 配置转发

socat, https://www.hi-linux.com/posts/61543.html


frp, https://github.com/fatedier/frp/blob/master/README_zh.md
- 一个内网穿透工具

frp 服务端配置, frps.ini:

```
[common]
bind_port = 7000

```

frp 客户端配置, frpc.ini:

```
[common]
server_addr = 192.168.43.245
server_port = 7000

[test_echo]
type = tcp
local_ip = 192.168.43.245
local_port = 6001
remote_port = 9001

[http_proxy]
type = tcp
remote_port = 6000
plugin = http_proxy
plugin_http_user = abc
plugin_http_passwd = abc
```

启动 frp 服务端: `./frps -c ./frps.ini`

启动 frp 客户端: `./frpc -c ./frpc.ini`



`/data/misc/wifi/hostpad.confg`, ignore_broadcast_ssid=1, 隐藏热点ssid
- https://blog.csdn.net/xzx208/article/details/79622183

<br>

python list to str:

```python
list1 = [1, 2, 3]
str1 = ''.join(str(e) for e in list1)
```



---

## 2019.09.03

mac terminal 网络命令:

```
查看路由
netstat -nr
```

---

## 2019.09.02

Flow tool:

- Flow
    - Nodes
    - Edges
    - state

- Node
  - id
  - inputs(edge id)
  - outputs(edge id)
  - type

- Edge
  - id
  - input_node_id(node id)
  - output_node_id(node id)
  - type: auto / custom
  - transfer()
  - auto_transfer(by action node ret, by node state, by flow state, by global state...)
